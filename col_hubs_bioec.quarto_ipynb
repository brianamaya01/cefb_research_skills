{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Level of readiness of the bioeconomy in Colombia\"\n",
        "description: \"Analysis of the capacities of departments to develop the bioeconomy in Colombia at the departmental level\"\n",
        "categories:\n",
        "  - Bioeconomy\n",
        "  - Departments\n",
        "  - D3\n",
        "  - Humboldt Institute\n",
        "date: \"2023-04-20\"\n",
        "image: \"https://github.com/jadeynryan/orcas/blob/master/inst/img/leaflet_screenshot.png?raw=true\"\n",
        "toc: true\n",
        "---\n",
        "\n",
        "```{ojs}\n",
        "d3 = require(\"d3@7\")\n",
        "navio_npm = require(\"navio@0.0.75\")\n",
        "Inputs = require(\"@observablehq/inputs\")\n",
        "htl = require(\"htl\")\n",
        "\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "aq = {\n",
        "  const aq = await require(`arquero@${aq_version}`);\n",
        "\n",
        "  // Add HTML table view method to tables\n",
        "  Object.assign(aq.ColumnTable.prototype, {\n",
        "    view(options) { return toView(this, options); }\n",
        "  });\n",
        "\n",
        "  return aq;\n",
        "}\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "aq_version = '7.2.0'\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "op = aq.op\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "toView = {\n",
        "  const DEFAULT_LIMIT = 100;\n",
        "  const DEFAULT_NULL = value => `<span style=\"color: #999;\">${value}</span>`;\n",
        "  const tableStyle = 'margin: 0; border-collapse: separate; border-spacing: 0; width: initial;';\n",
        "  const cellStyle = 'padding: 1px 5px; white-space: nowrap; overflow-x: hidden; text-overflow: ellipsis; font-variant-numeric: tabular-nums;';\n",
        "  const rowStyle = 'border-bottom: 1px solid #eee;';\n",
        "\n",
        "  // given an Arquero data table, provide an HTML table view\n",
        "  return function(dt, opt = {}) {\n",
        "    // permit shorthand for limit\n",
        "    if (typeof opt === 'number') opt = { limit: opt };\n",
        "    \n",
        "    // marshal cell color options\n",
        "    const color = { ...opt.color };\n",
        "    if (typeof opt.color === 'function') {\n",
        "      // if function, apply to all columns\n",
        "      dt.columnNames().forEach(name => color[name] = opt.color);\n",
        "    } else {\n",
        "      // otherwise, gather per-column color options\n",
        "      for (const key in color) {\n",
        "        const value = color[key];\n",
        "        color[key] = typeof value === 'function' ? value : () => value;\n",
        "      }\n",
        "    }\n",
        "\n",
        "    // marshal CSS styles as toHTML() options\n",
        "    const table = `${tableStyle}`;\n",
        "    const cell = (name, index, row, th) => {\n",
        "      return `${cellStyle} max-width: ${+opt.maxCellWidth || 300}px;`\n",
        "        + ` border-bottom: solid 1px ${th ? '#ccc' : '#eee'};`\n",
        "        + (color[name] ? ` background-color: ${color[name](index, row)};` : '');\n",
        "    };\n",
        "    const td = (name, index, row) => cell(name, index, row, false);\n",
        "    const th = (name, index, row) => `position: sticky; top: 0; background: #fff; `\n",
        "        + cell(name, index, row, true);\n",
        "\n",
        "    opt = {\n",
        "      limit: DEFAULT_LIMIT,\n",
        "      null: DEFAULT_NULL,\n",
        "      ...opt,\n",
        "      style: { table, td, th }\n",
        "    };\n",
        "\n",
        "    // return container div, bind table value to support viewof operator\n",
        "    const size = `max-height: ${+opt.height || 270}px`;\n",
        "    const style = `${size}; overflow-x: auto; overflow-y: auto;`;\n",
        "    const view = html`<div style=\"${style}\">${dt.toHTML(opt)}</div>`;\n",
        "    return Object.assign(view, { value: dt });\n",
        "  };\n",
        "}\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "function Scrubber(values, {\n",
        "  format = value => value,\n",
        "  initial = 0,\n",
        "  direction = 1,\n",
        "  delay = null,\n",
        "  autoplay = true,\n",
        "  loop = true,\n",
        "  loopDelay = null,\n",
        "  alternate = false\n",
        "} = {}) {\n",
        "  values = Array.from(values);\n",
        "  const form = html`<form style=\"font: 12px var(--sans-serif); font-variant-numeric: tabular-nums; display: flex; height: 33px; align-items: center;\">\n",
        "  <button name=b type=button style=\"margin-right: 0.4em; width: 5em;\"></button>\n",
        "  <label style=\"display: flex; align-items: center;\">\n",
        "    <input name=i type=range min=0 max=${values.length - 1} value=${initial} step=1 style=\"width: 180px;\">\n",
        "    <output name=o style=\"margin-left: 0.4em;\"></output>\n",
        "  </label>\n",
        "</form>`;\n",
        "  let frame = null;\n",
        "  let timer = null;\n",
        "  let interval = null;\n",
        "  function start() {\n",
        "    form.b.textContent = \"Pause\";\n",
        "    if (delay === null) frame = requestAnimationFrame(tick);\n",
        "    else interval = setInterval(tick, delay);\n",
        "  }\n",
        "  function stop() {\n",
        "    form.b.textContent = \"Play\";\n",
        "    if (frame !== null) cancelAnimationFrame(frame), frame = null;\n",
        "    if (timer !== null) clearTimeout(timer), timer = null;\n",
        "    if (interval !== null) clearInterval(interval), interval = null;\n",
        "  }\n",
        "  function running() {\n",
        "    return frame !== null || timer !== null || interval !== null;\n",
        "  }\n",
        "  function tick() {\n",
        "    if (form.i.valueAsNumber === (direction > 0 ? values.length - 1 : direction < 0 ? 0 : NaN)) {\n",
        "      if (!loop) return stop();\n",
        "      if (alternate) direction = -direction;\n",
        "      if (loopDelay !== null) {\n",
        "        if (frame !== null) cancelAnimationFrame(frame), frame = null;\n",
        "        if (interval !== null) clearInterval(interval), interval = null;\n",
        "        timer = setTimeout(() => (step(), start()), loopDelay);\n",
        "        return;\n",
        "      }\n",
        "    }\n",
        "    if (delay === null) frame = requestAnimationFrame(tick);\n",
        "    step();\n",
        "  }\n",
        "  function step() {\n",
        "    form.i.valueAsNumber = (form.i.valueAsNumber + direction + values.length) % values.length;\n",
        "    form.i.dispatchEvent(new CustomEvent(\"input\", {bubbles: true}));\n",
        "  }\n",
        "  form.i.oninput = event => {\n",
        "    if (event && event.isTrusted && running()) stop();\n",
        "    form.value = values[form.i.valueAsNumber];\n",
        "    form.o.value = format(form.value, form.i.valueAsNumber, values);\n",
        "  };\n",
        "  form.b.onclick = () => {\n",
        "    if (running()) return stop();\n",
        "    direction = alternate && form.i.valueAsNumber === values.length - 1 ? -1 : 1;\n",
        "    form.i.valueAsNumber = (form.i.valueAsNumber + direction) % values.length;\n",
        "    form.i.dispatchEvent(new CustomEvent(\"input\", {bubbles: true}));\n",
        "    start();\n",
        "  };\n",
        "  form.i.oninput();\n",
        "  if (autoplay) start();\n",
        "  else stop();\n",
        "  Inputs.disposal(form).then(stop);\n",
        "  return form;\n",
        "}\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "async function navio(data, _options = {}) {\n",
        "  const options = {\n",
        "    height: 300, // Navio's height\n",
        "    attribs: null, // array of attrib names to be used, leave as null for all of them\n",
        "\n",
        "    x0: 0, //Where to start drawing navio in x\n",
        "    y0: 100, //Where to start drawing navio in y, useful if your attrib names are too long\n",
        "    maxNumDistictForCategorical: 10, // addAllAttribs uses this for deciding if an attribute is categorical (has less than     maxNumDistictForCategorical categories) or ordered\n",
        "    maxNumDistictForOrdered: 90, // addAllAttribs uses this for deciding if an attribute is ordered (has less than     maxNumDistictForCategorical categories) or text. Use    maxNumDistictForOrdered : Infinity for never choosing Text\n",
        "\n",
        "    howManyItemsShouldSearchForNotNull: 100, // How many rows should addAllAttribs search to decide guess an attribute type\n",
        "    margin: 10, // Margin around navio\n",
        "\n",
        "    levelsSeparation: 40, // Separation between the levels\n",
        "    divisionsColor: \"white\", // Border color for the divisions\n",
        "    levelConnectionsColor: \"rgba(205, 220, 163, 0.5)\", // Color for the conections between levels\n",
        "    divisionsThreshold: 4, // What's the minimum row height needed to draw divisions\n",
        "    fmtCounts: d3.format(\",.0d\"), // Format used to display the counts on the bottom\n",
        "    legendFont: \"14px sans-serif\", // The font for the header\n",
        "    nestedFilters: true, // Should navio use nested levels?\n",
        "\n",
        "    showAttribTitles: true, // Show headers?\n",
        "    attribWidth: 15, // Width of the columns\n",
        "    attribRotation: -45, // Headers rotation\n",
        "    attribFontSize: 13, // Headers font size\n",
        "    attribFontSizeSelected: 32, // Headers font size when mouse over\n",
        "\n",
        "    filterFontSize: 10, // Font size of the filters explanations on the bottom\n",
        "\n",
        "    tooltipFontSize: 12, // Font size for the tooltip\n",
        "    tooltipBgColor: \"#b2ddf1\", // Font color for tooltip background\n",
        "    tooltipMargin: 50, // How much to separate the tooltip from the cursor\n",
        "    tooltipArrowSize: 10, // How big is the arrow on the tooltip\n",
        "\n",
        "    digitsForText: 2, // How many digits to use for text attributes\n",
        "\n",
        "    addAllAttribsRecursionLevel: Infinity, // How many levels depth do we keep on adding nested attributes\n",
        "    addAllAttribsIncludeObjects: true, // Should addAllAttribs include objects\n",
        "    addAllAttribsIncludeArrays: true, // Should addAllAttribs include arrays\n",
        "\n",
        "    nullColor: \"#ffedfd\", // Color for null values\n",
        "    defaultColorInterpolator: d3.interpolateBlues,\n",
        "    defaultColorInterpolatorDate: d3.interpolatePurples,\n",
        "    defaultColorInterpolatorDiverging: d3.interpolateBrBG,\n",
        "    defaultColorInterpolatorOrdered: d3.interpolateOranges,\n",
        "    defaultColorInterpolatorText: d3.interpolateGreys,\n",
        "    defaultColorRangeBoolean: [\"#a1d76a\", \"#e9a3c9\", \"white\"], //true false null\n",
        "    defaultColorRangeSelected: [\"white\", \"#b5cf6b\"],\n",
        "    defaultColorCategorical: d3.schemeCategory10,\n",
        "\n",
        "    showSelectedAttrib: true, // Display the attribute that shows if a row is selected\n",
        "    showSequenceIDAttrib: true, // Display the attribute with the sequence ID\n",
        "\n",
        "    ..._options\n",
        "  };\n",
        "\n",
        "  let div = html`<div  style=\"display:block; overflow-x:scroll\"></div>`;\n",
        "  \n",
        "  // Create the navio\n",
        "  const nv = navio_npm(d3.select(div), options.height);\n",
        "\n",
        "  for (let opt in options) {\n",
        "    if (opt === \"id\") {\n",
        "      nv.id(options[opt]);\n",
        "    } else if (opt !== \"attribs\") {\n",
        "      nv[opt] = options[opt];\n",
        "    }\n",
        "  }\n",
        "\n",
        "  // Add the data\n",
        "  nv.data(data);\n",
        "\n",
        "  if (options.attribs) {\n",
        "    nv.addAllAttribs(options.attribs);\n",
        "  } else {\n",
        "    nv.addAllAttribs();\n",
        "  }\n",
        "\n",
        "  nv.updateCallback(() => {\n",
        "    div.value = nv.getVisible();\n",
        "    div.dispatchEvent(new Event(\"input\", { bubbles: true }));\n",
        "    // notify(div);\n",
        "  });\n",
        "\n",
        "  div.value = data;\n",
        "  div.nv = nv;\n",
        "  return div;\n",
        "}\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "data_hubs0 = FileAttachment(\"Hubs_bioec_col.csv\").csv({ typed: true })\n",
        "data_hubs = data_hubs0.map(d => ({ ...d, name: d.plataforma, type: \"Bioeconomy\" }));\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "dData = new Map(data_hubs.map(d => [d.name, d]))\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "hullColor = d3.scaleOrdinal(\n",
        "  d3.quantize(\n",
        "    colorInterpolator,\n",
        "    tidyData.groupby(groupBy).count().objects().length\n",
        "  )\n",
        ")\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "dConnections = new Map()\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "graph = {\n",
        "  for (let n of dData.values()) {\n",
        "    n.degree = 0;\n",
        "  }\n",
        "\n",
        "  const linksArray = links.objects();\n",
        "  for (let l of linksArray) {\n",
        "    const source = dData.get(l.source);\n",
        "    // target = dNodes.get(l.target);\n",
        "\n",
        "    source.cluster = l.target;\n",
        "    // target.cluster = l.target;\n",
        "    source.degree += 1;\n",
        "    // target.degree += 1;\n",
        "  }\n",
        "\n",
        "  const getOrCreateNode = (name) => {\n",
        "    let node = dConnections.get(name);\n",
        "\n",
        "    if (!node) {\n",
        "      node = {\n",
        "        name,\n",
        "        type: \"Connection\",\n",
        "        cluster: name,\n",
        "        x: width / 2 + (Math.random() * width) / 10,\n",
        "        y: fheight_node.height / 2 + (Math.random() * fheight_node.height) / 10\n",
        "      };\n",
        "      dConnections.set(name, node);\n",
        "    }\n",
        "    return node;\n",
        "  };\n",
        "\n",
        "  // --------- Filter Links and Nodes --------------\n",
        "  const filteredLinks = linksArray.map((l) => {\n",
        "    return {\n",
        "      source: dData.get(l.source),\n",
        "      target: getOrCreateNode(l.target)\n",
        "    };\n",
        "  });\n",
        "\n",
        "  const filteredNodesObject = filteredLinks.reduce(\n",
        "    (p, l) => {\n",
        "      if (!p.set.has(l.source.name)) {\n",
        "        p.set.add(l.source.name);\n",
        "        p.list.push(l.source);\n",
        "      }\n",
        "      if (!p.set.has(l.target.name)) {\n",
        "        p.set.add(l.target.name);\n",
        "        p.list.push(l.target);\n",
        "      }\n",
        "\n",
        "      return p;\n",
        "    },\n",
        "    { set: new Set(), list: [] }\n",
        "  );\n",
        "\n",
        "  // Clusters is used for the hulls\n",
        "  const clusters = d3.rollups(\n",
        "    filteredLinks,\n",
        "    (v) => v.map((l) => l.source).concat([v[0].target]),\n",
        "    (d) => d.target.name\n",
        "  );\n",
        "\n",
        "  return {\n",
        "    nodes: filteredNodesObject.list,\n",
        "    links: linksArray,\n",
        "    clusters: clusters\n",
        "  };\n",
        "}\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "dateFmt = d3.timeParse(\"%m/%d/%y\")\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "tidyData = aq\n",
        "  .from(data_hubs)\n",
        "  .derive({\n",
        "    \"linea_investigacion\": (d) =>\n",
        "      d[\"linea_investigacion\"] === null ? [null] : op.split(d[\"linea_investigacion\"], \";\"),\n",
        "    \"departamento\": (d) =>\n",
        "      d[\"departamento\"] === null ? [null] : op.split(d[\"departamento\"], \";\")\n",
        "  })\n",
        "  .unroll(\"linea_investigacion\")\n",
        "  .unroll(\"departamento\")\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "links = tidyData\n",
        "  .filter(aq.escape((d) => !d.ano_creacion || d.ano_creacion <= minDate)) // Filter by Date\n",
        "  .derive({\n",
        "    source: (d) => d.name,\n",
        "    target: aq.escape((d) => d[groupBy])\n",
        "  })\n",
        "  .groupby([\"source\", \"target\"])\n",
        "  .count()\n",
        "  .filter((d) => d.target && d.source) // Ignore nulls\n",
        "  .filter(aq.escape((d) => selectedTargets.includes(d.target))) // Filter by selectedTarget\n",
        "  .select([\"source\", \"target\"])\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "targets = links\n",
        "  .groupby(\"target\")\n",
        "  .count()\n",
        "  .rename({ target: \"name\" })\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "sources = links\n",
        "  .groupby(\"source\")\n",
        "  .count()\n",
        "  .rename({ source: \"name\" })\n",
        "  .derive({ type: () => \"Bioeconomy\" })\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "col_names = Object.keys(data_hubs[0])\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "template = (inputs) => \n",
        "htl.html`<div class=\"styled\">${Object.values(inputs)}</div>\n",
        "<style>\n",
        "  div.styled {\n",
        "    text-align: left;\n",
        "    column-count: 2\n",
        "  }\n",
        "  div.styled label {\n",
        "    font-weight: bold;\n",
        "    line-height: 200%;\n",
        "  }\n",
        "  div.styled label:not(div>label):after {\n",
        "    content: \":\";\n",
        "  }\n",
        "</style>`\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof minDate = {\n",
        "  const dates = data_hubs\n",
        "    .map((d) => d.ano_creacion)\n",
        "    .filter((d) => d)\n",
        "    .sort((a, b) => d3.ascending(+a, +b));\n",
        "  return Scrubber(dates, {\n",
        "    delay: 500,\n",
        "    autoplay: false,\n",
        "    loop:false,\n",
        "    initial: dates.length-1\n",
        "  });\n",
        "}\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof groupBy = {\n",
        "  // `[\"Last Name\",\"First Name\",\"Appointments\",\"Job Profile\",\"Picture URL\",\"Research Areas\",\"Labs and Groups\",\"Institutes and Centers\",\"Date of joining NU\",\"Courses\",\"Campus\",\"Supervisory Organization\",\"Title\",\"Academic Track Type\",\"Degrees\",\"Last School Attended\",\"Year Highest Degree Received\",\"Interdisciplinary Dept 1\",\"Interdisciplinary College 1\",\"Interdisciplinary Dept 2\",\"Interdisciplinary College 2\",\"Interdisciplinary Dept 3\",\"Interdisciplinary College 3\",\"name\",\"selected\",\"__seqId\",\"__i\",\"Appointment\"]`\n",
        "\n",
        "  const attrs = [\n",
        "  //\"plataforma\",\n",
        "  //\"descripcion\",\n",
        "  //\"link\",\n",
        "  \"tematica\",\n",
        "  \"fases\",\n",
        "  \"relacion\",\n",
        "  \"linea_investigacion\",\n",
        "  //\"partners\",\n",
        "  //\"country_host\",\n",
        "  ////\"ano_creacion\",\n",
        "  //\"departamentos\",\n",
        "  //\"def_bioeconomia\"\n",
        "  //\"relaciones\"\n",
        "  //\"logo\"\n",
        "  //\"logo_viz\"\n",
        "  //\"lat_host\"\n",
        "  //\"long_host\"\n",
        "  ];\n",
        "  return Inputs.select(attrs, { label: \"Agrupación\", value: \"fases\" });\n",
        "}\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof selectedTargets = {\n",
        "  const targetNames = tidyData\n",
        "    .groupby(groupBy)\n",
        "    .count()\n",
        "    .objects()\n",
        "    .map((d) => d[groupBy])\n",
        "    .filter((d) => d);\n",
        "  const selection =\n",
        "    groupBy === \"linea_investigacion\"\n",
        "      ? targetNames.filter((d) => ![\"Bioindustría\",\"Bioenergía\",\"Forestal\"].includes(d))\n",
        "      : targetNames;\n",
        "  const cr = 15;\n",
        "  return Inputs.checkbox(targetNames, {\n",
        "    label: \"Show\",\n",
        "    value: selection,\n",
        "    format: (d) => html`<div style=\"height: ${cr}px;\n",
        "    line-height: ${cr}px; \n",
        "    display: flex;\n",
        "    align-content: center;\n",
        "    flex-wrap: wrap;\n",
        "\"><svg width=${cr} height=${cr} style=\"margin-right:5px\">\n",
        "<circle r=${cr / 2} cx=${cr / 2} cy=${cr / 2} fill=\"${hullColor(d)}\"/> \n",
        "</svg>\n",
        "${d}</div>`\n",
        "  });\n",
        "}\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof fheight_node = (\n",
        "  Inputs.form({\n",
        "  height: Inputs.range([200, 1400], {label: \"Height\", step:1, value: 420}),\n",
        "  nodeSize: Inputs.range([2, 30], {label: \"Node Size\",value: 23,step: 1})},\n",
        "          \n",
        "   // borrowed template from Allison Horst - splits up in two columns\n",
        "      {template})\n",
        "  )\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "::: {#chart-container}\n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "```{js}\n",
        "chart = {\n",
        "  const container = document.querySelector(\"#chart-container\");  // Selecciona el contenedor explícitamente\n",
        "  container.innerHTML = \"\";  // Limpia el contenedor antes de agregar el SVG\n",
        "\n",
        "  const svg = d3.create(\"svg\")\n",
        "    .attr(\"width\", width)\n",
        "    .attr(\"height\", fheight_node.height)\n",
        "    .attr(\"viewBox\", [0, 0, width, fheight_node.height])\n",
        "    .attr(\n",
        "      \"style\",\n",
        "      \"max-width: 100%; height: auto; height: intrinsic; overflow: visible\"\n",
        "    );\n",
        "\n",
        "  // Resto del código de tu gráfico aquí...\n",
        "  // Agrega el SVG al contenedor seleccionado\n",
        "  container.appendChild(svg.node());\n",
        "\n",
        "  return container;\n",
        "};\n",
        "\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof colorInterpolator = {\n",
        "  const colorSchemes = [\n",
        "    \"interpolateBlues\",\n",
        "    \"interpolateBrBG\",\n",
        "    \"interpolateBuGn\",\n",
        "    \"interpolateBuPu\",\n",
        "    \"interpolateCividis\",\n",
        "    \"interpolateCool\",\n",
        "    \"interpolateCubehelixDefault\",\n",
        "    \"interpolateGnBu\",\n",
        "    \"interpolateGreens\",\n",
        "    \"interpolateGreys\",\n",
        "    \"interpolateInferno\",\n",
        "    \"interpolateMagma\",\n",
        "    \"interpolateOrRd\",\n",
        "    \"interpolateOranges\",\n",
        "    \"interpolatePRGn\",\n",
        "    \"interpolatePiYG\",\n",
        "    \"interpolatePlasma\",\n",
        "    \"interpolatePuBu\",\n",
        "    \"interpolatePuBuGn\",\n",
        "    \"interpolatePuOr\",\n",
        "    \"interpolatePuRd\",\n",
        "    \"interpolatePurples\",\n",
        "    \"interpolateRainbow\",\n",
        "    \"interpolateRdBu\",\n",
        "    \"interpolateRdGy\",\n",
        "    \"interpolateRdPu\",\n",
        "    \"interpolateRdYlBu\",\n",
        "    \"interpolateRdYlGn\",\n",
        "    \"interpolateReds\",\n",
        "    \"interpolateSinebow\",\n",
        "    \"interpolateSpectral\",\n",
        "    \"interpolateString\",\n",
        "    \"interpolateTurbo\",\n",
        "    \"interpolateViridis\",\n",
        "    \"interpolateWarm\",\n",
        "    \"interpolateYlGn\",\n",
        "    \"interpolateYlGnBu\",\n",
        "    \"interpolateYlOrBr\",\n",
        "    \"interpolateYlOrRd\"\n",
        "  ];\n",
        "  const colors = new Map(\n",
        "    [[\"Custom Turbo\", (t) => d3.interpolateTurbo(0.2 + t * 0.8)]].concat(\n",
        "      colorSchemes.map((c) => [c, d3[c]])\n",
        "    )\n",
        "  );\n",
        "\n",
        "  return Inputs.select(colors, {\n",
        "    label: \"Color Scheme\",\n",
        "    format: (d) => d[0]\n",
        "  });\n",
        "}\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof ffsize_gnode = (\n",
        "  Inputs.form({\n",
        "  fontSize:Inputs.range([1, 36], {label: \"Font size\", value: 8, step: 1}),\n",
        "  greyNodeSize:Inputs.range([1, 30], {label: \"Connecting Node Size\", value: 5, step: 1})},\n",
        "          \n",
        "   // borrowed template from Allison Horst - splits up in two columns\n",
        "      {template})\n",
        "  )\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof fimage_gnodes = (\n",
        "  Inputs.form({\n",
        "  useImages:Inputs.toggle({label: \"Use Images\", value: true}),\n",
        "  showGroupingNodes:Inputs.toggle({label: \"Show grey nodes\", value: true})},\n",
        "          \n",
        "   // borrowed template from Allison Horst - splits up in two columns\n",
        "      {template})\n",
        ")\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof fclabels_tshadows = (\n",
        "  Inputs.form({\n",
        "  clipLabels: Inputs.toggle({label: \"Clip Labels\", value: true}),\n",
        "  useShadowsText: Inputs.toggle({label: \"Use Text Shadows\", value: true})},\n",
        "          \n",
        "   // borrowed template from Allison Horst - splits up in two columns\n",
        "      {template})\n",
        ")\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof fhpadding_mdlabel = (\n",
        "  Inputs.form({\n",
        "  hullPadding: Inputs.range([0, 100], {label: \"Hull Padding\", value: 9, step: 1}),\n",
        "  minDegree: Inputs.range([0, d3.max(graph.nodes, (d) => d.degree)+1], {\n",
        "  label: \"Min Degree for Label\",\n",
        "  value: this !== undefined ? this.value : 1,\n",
        "  step: 1\n",
        "})},\n",
        "          \n",
        "   // borrowed template from Allison Horst - splits up in two columns\n",
        "      {template})\n",
        "  )\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof hullPadding = Inputs.range([0, 100], {label: \"Hull Padding\", value: 9, step: 1})\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof minDegree = Inputs.range([0, d3.max(graph.nodes, (d) => d.degree)+1], {\n",
        "  label: \"Min Degree for Label\",\n",
        "  value: this !== undefined ? this.value : 1,\n",
        "  step: 1\n",
        "})\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof useShadowsNodes = Inputs.toggle({label: \"Use Node Shadows\", value: true})\n",
        "```\n",
        "\n",
        "```{ojs}\n",
        "viewof excludeKhouryHull = Inputs.toggle({label: \"Exclude Khoury Hull\", value: true})\n",
        "```"
      ],
      "id": "b8083e8a"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}